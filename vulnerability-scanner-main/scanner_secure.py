#!/usr/bin/env python3
"""
scanner_secure.py
Secure version of the vulnerability scanner for CodeAlpha internship submission.

Features / fixes:
- Uses argparse for CLI options
- Validates input (IP or URL)
- Uses request timeouts and handles SSL errors
- Optional --allow-insecure flag (explicit) for testing, with warning
- Better exception handling and logging
- Configurable port scan range and delay between probes
"""

import argparse
import socket
import logging
import re
import sys
import time
from urllib.parse import urlparse

import requests

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")


def validate_ip(ip: str) -> bool:
    # Simple IPv4 validation
    pattern = r"^\d{1,3}(\.\d{1,3}){3}$"
    return re.match(pattern, ip) is not None


def validate_url(url: str) -> bool:
    try:
        result = urlparse(url)
        return all([result.scheme in ("http", "https"), result.netloc])
    except Exception:
        return False


def scan_ports(target_ip: str, start_port: int = 1, end_port: int = 1024, delay: float = 0.01, timeout: float = 0.5):
    logging.info("Scanning ports on %s (ports %d–%d)...", target_ip, start_port, end_port)
    open_ports = []
    for port in range(start_port, end_port + 1):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(timeout)
                result = sock.connect_ex((target_ip, port))
                if result == 0:
                    logging.info("[OPEN] Port %d", port)
                    open_ports.append(port)
        except socket.error as e:
            logging.debug("Socket error on port %d: %s", port, e)
        # polite delay to reduce IDS/DoS risk
        if delay:
            time.sleep(delay)
    if not open_ports:
        logging.warning("No open ports found.")
    else:
        logging.info("Open ports found: %s", open_ports)
    return open_ports


def analyze_headers(url: str, allow_insecure: bool = False, timeout: float = 5.0):
    logging.info("Analyzing HTTP headers for: %s", url)
    try:
        if allow_insecure:
            logging.warning("Insecure SSL verification is enabled by --allow-insecure (use only for testing).")
            response = requests.get(url, timeout=timeout, verify=False)
        else:
            response = requests.get(url, timeout=timeout)  # verify=True by default
        logging.info("Response status: %s", response.status_code)
        logging.info("Response Headers:")
        for header, value in response.headers.items():
            logging.info("%s: %s", header, value)

        # Security header checks
        security_headers = [
            "Content-Security-Policy",
            "X-Frame-Options",
            "X-XSS-Protection",
            "Strict-Transport-Security",
            "Referrer-Policy",
            "Permissions-Policy",
        ]
        for header in security_headers:
            if header in response.headers:
                logging.info("%s is set ✅", header)
            else:
                logging.warning("%s is NOT set ❌", header)

    except requests.exceptions.SSLError as e:
        logging.error("SSL error when connecting to %s: %s", url, e)
        logging.info("If you trust this host for testing, re-run with --allow-insecure (not recommended for production).")
    except requests.exceptions.Timeout:
        logging.error("Request to %s timed out (timeout=%s).", url, timeout)
    except requests.exceptions.RequestException as e:
        logging.error("Error fetching headers from %s: %s", url, e)


def main():
    parser = argparse.ArgumentParser(description="Secure Vulnerability Scanner (CodeAlpha submission)")
    parser.add_argument("target", help="Target IP (for port scan) or full URL (for header analysis)")
    parser.add_argument("--start-port", type=int, default=1, help="Start port for port scanning (default 1)")
    parser.add_argument("--end-port", type=int, default=1024, help="End port for port scanning (default 1024)")
    parser.add_argument("--delay", type=float, default=0.01, help="Delay (seconds) between port probes")
    parser.add_argument("--timeout", type=float, default=0.5, help="Socket timeout for port scan (seconds)")
    parser.add_argument("--request-timeout", type=float, default=5.0, help="Timeout for HTTP requests (seconds)")
    parser.add_argument("--allow-insecure", action="store_true", help="Allow insecure SSL (verify=False) — only for testing")
    args = parser.parse_args()

    target = args.target.strip()

    if validate_url(target):
        analyze_headers(target, allow_insecure=args.allow_insecure, timeout=args.request_timeout)
    elif validate_ip(target):
        scan_ports(target, start_port=args.start_port, end_port=args.end_port, delay=args.delay, timeout=args.timeout)
    else:
        logging.error("Invalid target format. Provide a valid IPv4 address or a full URL (http:// or https://).")
        sys.exit(1)


if __name__ == "__main__":
    main()
